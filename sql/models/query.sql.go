// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package models

import (
	"context"
	"time"
)

const getExistingSlot = `-- name: GetExistingSlot :one
SELECT 1
FROM slot s
WHERE 1=1
	AND id_professional = ?
	AND datetime(?) between datetime(slot) and datetime(slot, concat(s."interval" - 1, ' minute'))
    AND priority_entry = ?
`

type GetExistingSlotParams struct {
	IDProfessional int64       `json:"id_professional"`
	Datetime       interface{} `json:"datetime"`
	PriorityEntry  int64       `json:"priority_entry"`
}

func (q *Queries) GetExistingSlot(ctx context.Context, arg GetExistingSlotParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getExistingSlot, arg.IDProfessional, arg.Datetime, arg.PriorityEntry)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const insertAvailability = `-- name: InsertAvailability :one





INSERT INTO availability (
    id_professional,
    init_datetime,
    end_datetime,
    init_hour,
    end_hour,
    type_availability,
    weekday_name,
    interval,
    priority_entry
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?
)
RETURNING id_availability, id_professional, init_datetime, end_datetime, init_hour, end_hour, type_availability, weekday_name, interval, priority_entry
`

type InsertAvailabilityParams struct {
	IDProfessional   int64  `json:"id_professional"`
	InitDatetime     string `json:"init_datetime"`
	EndDatetime      string `json:"end_datetime"`
	InitHour         string `json:"init_hour"`
	EndHour          string `json:"end_hour"`
	TypeAvailability int64  `json:"type_availability"`
	WeekdayName      string `json:"weekday_name"`
	Interval         int64  `json:"interval"`
	PriorityEntry    int64  `json:"priority_entry"`
}

// -- name: GetAuthor :one
// SELECT * FROM authors
// WHERE id = ? LIMIT 1;
// -- name: ListAuthors :many
// SELECT * FROM authors
// ORDER BY name;
// -- name: CreateAuthor :one
// INSERT INTO authors (
//
//	name, bio
//
// ) VALUES (
//
//	?, ?
//
// )
// RETURNING *;
// -- name: UpdateAuthor :exec
// UPDATE authors
// set name = ?,
// bio = ?
// WHERE id = ?;
// -- name: DeleteAuthor :exec
// DELETE FROM authors
// WHERE id = ?;
func (q *Queries) InsertAvailability(ctx context.Context, arg InsertAvailabilityParams) (Availability, error) {
	row := q.db.QueryRowContext(ctx, insertAvailability,
		arg.IDProfessional,
		arg.InitDatetime,
		arg.EndDatetime,
		arg.InitHour,
		arg.EndHour,
		arg.TypeAvailability,
		arg.WeekdayName,
		arg.Interval,
		arg.PriorityEntry,
	)
	var i Availability
	err := row.Scan(
		&i.IDAvailability,
		&i.IDProfessional,
		&i.InitDatetime,
		&i.EndDatetime,
		&i.InitHour,
		&i.EndHour,
		&i.TypeAvailability,
		&i.WeekdayName,
		&i.Interval,
		&i.PriorityEntry,
	)
	return i, err
}

const insertSlot = `-- name: InsertSlot :exec
INSERT INTO slot (
    id_professional,
    id_availability,
    slot,
    weekday_name,
    interval,
    priority_entry
) VALUES (
    ?, ?, ?, ?, ?, ?
)
RETURNING id_slot, id_availability, id_professional, slot, weekday_name, interval, priority_entry
`

type InsertSlotParams struct {
	IDProfessional int64     `json:"id_professional"`
	IDAvailability int64     `json:"id_availability"`
	Slot           time.Time `json:"slot"`
	WeekdayName    string    `json:"weekday_name"`
	Interval       int64     `json:"interval"`
	PriorityEntry  int64     `json:"priority_entry"`
}

func (q *Queries) InsertSlot(ctx context.Context, arg InsertSlotParams) error {
	_, err := q.db.ExecContext(ctx, insertSlot,
		arg.IDProfessional,
		arg.IDAvailability,
		arg.Slot,
		arg.WeekdayName,
		arg.Interval,
		arg.PriorityEntry,
	)
	return err
}

const listAvailability = `-- name: ListAvailability :one
SELECT 
    id_availability,
    id_professional,
    init_datetime,
    end_datetime,
    init_hour,
    end_hour,
    type_availability,
    weekday_name,
    interval,
    priority_entry
FROM availability
WHERE id_availability = ? LIMIT 1
`

func (q *Queries) ListAvailability(ctx context.Context, idAvailability int64) (Availability, error) {
	row := q.db.QueryRowContext(ctx, listAvailability, idAvailability)
	var i Availability
	err := row.Scan(
		&i.IDAvailability,
		&i.IDProfessional,
		&i.InitDatetime,
		&i.EndDatetime,
		&i.InitHour,
		&i.EndHour,
		&i.TypeAvailability,
		&i.WeekdayName,
		&i.Interval,
		&i.PriorityEntry,
	)
	return i, err
}
