// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package models

import (
	"context"
	"time"
)

const deleteAvailabilityById = `-- name: DeleteAvailabilityById :one
UPDATE availability
SET is_deleted = 1
WHERE id_availability == ?1
RETURNING id_availability, id_professional, init_datetime, end_datetime, init_hour, end_hour, type_availability, weekday_name, interval, priority_entry, is_deleted
`

func (q *Queries) DeleteAvailabilityById(ctx context.Context, idAvailability int64) (Availability, error) {
	row := q.db.QueryRowContext(ctx, deleteAvailabilityById, idAvailability)
	var i Availability
	err := row.Scan(
		&i.IDAvailability,
		&i.IDProfessional,
		&i.InitDatetime,
		&i.EndDatetime,
		&i.InitHour,
		&i.EndHour,
		&i.TypeAvailability,
		&i.WeekdayName,
		&i.Interval,
		&i.PriorityEntry,
		&i.IsDeleted,
	)
	return i, err
}

const deleteSlotById = `-- name: DeleteSlotById :exec
UPDATE slot
SET is_deleted = 1
WHERE id_slot == ?1
`

func (q *Queries) DeleteSlotById(ctx context.Context, idSlot int64) error {
	_, err := q.db.ExecContext(ctx, deleteSlotById, idSlot)
	return err
}

const getExistingSlot = `-- name: GetExistingSlot :one
SELECT 1
FROM slot s
WHERE 1=1
  AND is_deleted = 0
	AND id_professional = ?
	AND datetime(?) between datetime(slot) and datetime(slot, concat(s."interval" - 1, ' minute'))
    AND priority_entry = ?
`

type GetExistingSlotParams struct {
	IDProfessional int64       `json:"id_professional"`
	Datetime       interface{} `json:"datetime"`
	PriorityEntry  int64       `json:"priority_entry"`
}

func (q *Queries) GetExistingSlot(ctx context.Context, arg GetExistingSlotParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getExistingSlot, arg.IDProfessional, arg.Datetime, arg.PriorityEntry)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const getProfessionalInfo = `-- name: GetProfessionalInfo :one
SELECT
  id_professional,
  nome,
  especialidade
FROM professional
WHERE id_professional == ?1
`

type GetProfessionalInfoRow struct {
	IDProfessional int64  `json:"id_professional"`
	Nome           string `json:"nome"`
	Especialidade  string `json:"especialidade"`
}

func (q *Queries) GetProfessionalInfo(ctx context.Context, idProfessional int64) (GetProfessionalInfoRow, error) {
	row := q.db.QueryRowContext(ctx, getProfessionalInfo, idProfessional)
	var i GetProfessionalInfoRow
	err := row.Scan(&i.IDProfessional, &i.Nome, &i.Especialidade)
	return i, err
}

const insertAttribute = `-- name: InsertAttribute :one
INSERT INTO attribute (
  id_professional,
  attribute,
  value
) VALUES (
  ?1,
  ?2,
  ?3
) RETURNING id_attribute, id_professional, attribute, value
`

type InsertAttributeParams struct {
	IDProfessional int64  `json:"id_professional"`
	Attribute      string `json:"attribute"`
	Value          string `json:"value"`
}

func (q *Queries) InsertAttribute(ctx context.Context, arg InsertAttributeParams) (Attribute, error) {
	row := q.db.QueryRowContext(ctx, insertAttribute, arg.IDProfessional, arg.Attribute, arg.Value)
	var i Attribute
	err := row.Scan(
		&i.IDAttribute,
		&i.IDProfessional,
		&i.Attribute,
		&i.Value,
	)
	return i, err
}

const insertAvailability = `-- name: InsertAvailability :one
INSERT INTO availability (
    id_professional,
    init_datetime,
    end_datetime,
    init_hour,
    end_hour,
    type_availability,
    weekday_name,
    interval,
    priority_entry,
    is_deleted
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, 0
)
RETURNING id_availability, id_professional, init_datetime, end_datetime, init_hour, end_hour, type_availability, weekday_name, interval, priority_entry, is_deleted
`

type InsertAvailabilityParams struct {
	IDProfessional   int64  `json:"id_professional"`
	InitDatetime     string `json:"init_datetime"`
	EndDatetime      string `json:"end_datetime"`
	InitHour         string `json:"init_hour"`
	EndHour          string `json:"end_hour"`
	TypeAvailability int64  `json:"type_availability"`
	WeekdayName      string `json:"weekday_name"`
	Interval         int64  `json:"interval"`
	PriorityEntry    int64  `json:"priority_entry"`
}

func (q *Queries) InsertAvailability(ctx context.Context, arg InsertAvailabilityParams) (Availability, error) {
	row := q.db.QueryRowContext(ctx, insertAvailability,
		arg.IDProfessional,
		arg.InitDatetime,
		arg.EndDatetime,
		arg.InitHour,
		arg.EndHour,
		arg.TypeAvailability,
		arg.WeekdayName,
		arg.Interval,
		arg.PriorityEntry,
	)
	var i Availability
	err := row.Scan(
		&i.IDAvailability,
		&i.IDProfessional,
		&i.InitDatetime,
		&i.EndDatetime,
		&i.InitHour,
		&i.EndHour,
		&i.TypeAvailability,
		&i.WeekdayName,
		&i.Interval,
		&i.PriorityEntry,
		&i.IsDeleted,
	)
	return i, err
}

const insertProfessional = `-- name: InsertProfessional :one





INSERT INTO professional (
  nome,
  especialidade
) VALUES (
  ?, ?
)
RETURNING id_professional, especialidade, nome
`

type InsertProfessionalParams struct {
	Nome          string `json:"nome"`
	Especialidade string `json:"especialidade"`
}

// -- name: GetAuthor :one
// SELECT * FROM authors
// WHERE id = ? LIMIT 1;
// -- name: ListAuthors :many
// SELECT * FROM authors
// ORDER BY name;
// -- name: CreateAuthor :one
// INSERT INTO authors (
//
//	name, bio
//
// ) VALUES (
//
//	?, ?
//
// )
// RETURNING *;
// -- name: UpdateAuthor :exec
// UPDATE authors
// set name = ?,
// bio = ?
// WHERE id = ?;
// -- name: DeleteAuthor :exec
// DELETE FROM authors
// WHERE id = ?;
func (q *Queries) InsertProfessional(ctx context.Context, arg InsertProfessionalParams) (Professional, error) {
	row := q.db.QueryRowContext(ctx, insertProfessional, arg.Nome, arg.Especialidade)
	var i Professional
	err := row.Scan(&i.IDProfessional, &i.Especialidade, &i.Nome)
	return i, err
}

const insertSlot = `-- name: InsertSlot :exec
INSERT INTO slot (
    id_professional,
    id_availability,
    slot,
    weekday_name,
    interval,
    priority_entry,
    status_entry,
    is_deleted
) VALUES (
    ?, ?, ?, ?, ?, ?, 'Aberto', 0
)
RETURNING id_slot, id_availability, id_professional, slot, weekday_name, interval, priority_entry, status_entry, is_deleted
`

type InsertSlotParams struct {
	IDProfessional int64     `json:"id_professional"`
	IDAvailability int64     `json:"id_availability"`
	Slot           time.Time `json:"slot"`
	WeekdayName    string    `json:"weekday_name"`
	Interval       int64     `json:"interval"`
	PriorityEntry  int64     `json:"priority_entry"`
}

func (q *Queries) InsertSlot(ctx context.Context, arg InsertSlotParams) error {
	_, err := q.db.ExecContext(ctx, insertSlot,
		arg.IDProfessional,
		arg.IDAvailability,
		arg.Slot,
		arg.WeekdayName,
		arg.Interval,
		arg.PriorityEntry,
	)
	return err
}

const listAttributesByProfessionalId = `-- name: ListAttributesByProfessionalId :many
SELECT
  id_attribute,
  attribute,
  value
FROM attribute
WHERE id_professional == ?1
`

type ListAttributesByProfessionalIdRow struct {
	IDAttribute int64  `json:"id_attribute"`
	Attribute   string `json:"attribute"`
	Value       string `json:"value"`
}

func (q *Queries) ListAttributesByProfessionalId(ctx context.Context, idProfessional int64) ([]ListAttributesByProfessionalIdRow, error) {
	rows, err := q.db.QueryContext(ctx, listAttributesByProfessionalId, idProfessional)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAttributesByProfessionalIdRow
	for rows.Next() {
		var i ListAttributesByProfessionalIdRow
		if err := rows.Scan(&i.IDAttribute, &i.Attribute, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAvailability = `-- name: ListAvailability :one
SELECT 
    id_availability,
    id_professional,
    init_datetime,
    end_datetime,
    init_hour,
    end_hour,
    type_availability,
    weekday_name,
    interval,
    priority_entry,
    is_deleted
FROM availability
WHERE id_availability = ? LIMIT 1
`

func (q *Queries) ListAvailability(ctx context.Context, idAvailability int64) (Availability, error) {
	row := q.db.QueryRowContext(ctx, listAvailability, idAvailability)
	var i Availability
	err := row.Scan(
		&i.IDAvailability,
		&i.IDProfessional,
		&i.InitDatetime,
		&i.EndDatetime,
		&i.InitHour,
		&i.EndHour,
		&i.TypeAvailability,
		&i.WeekdayName,
		&i.Interval,
		&i.PriorityEntry,
		&i.IsDeleted,
	)
	return i, err
}

const listAvailabilityByProfessionalId = `-- name: ListAvailabilityByProfessionalId :many
SELECT
  id_availability,
  init_datetime,
  end_datetime,
  init_hour,
  end_hour,
  type_availability,
  weekday_name,
  interval,
  priority_entry,
  is_deleted
FROM availability
WHERE 1=1
  AND id_professional == ?1
  AND CASE WHEN ?2 == 1 THEN 1 ELSE is_deleted == 0 END
`

type ListAvailabilityByProfessionalIdParams struct {
	IDProfessional int64       `json:"id_professional"`
	Deleted        interface{} `json:"deleted"`
}

type ListAvailabilityByProfessionalIdRow struct {
	IDAvailability   int64  `json:"id_availability"`
	InitDatetime     string `json:"init_datetime"`
	EndDatetime      string `json:"end_datetime"`
	InitHour         string `json:"init_hour"`
	EndHour          string `json:"end_hour"`
	TypeAvailability int64  `json:"type_availability"`
	WeekdayName      string `json:"weekday_name"`
	Interval         int64  `json:"interval"`
	PriorityEntry    int64  `json:"priority_entry"`
	IsDeleted        int64  `json:"is_deleted"`
}

func (q *Queries) ListAvailabilityByProfessionalId(ctx context.Context, arg ListAvailabilityByProfessionalIdParams) ([]ListAvailabilityByProfessionalIdRow, error) {
	rows, err := q.db.QueryContext(ctx, listAvailabilityByProfessionalId, arg.IDProfessional, arg.Deleted)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAvailabilityByProfessionalIdRow
	for rows.Next() {
		var i ListAvailabilityByProfessionalIdRow
		if err := rows.Scan(
			&i.IDAvailability,
			&i.InitDatetime,
			&i.EndDatetime,
			&i.InitHour,
			&i.EndHour,
			&i.TypeAvailability,
			&i.WeekdayName,
			&i.Interval,
			&i.PriorityEntry,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSlots = `-- name: ListSlots :many
SELECT
  id_slot,
  id_professional,
  id_availability,
  slot,
  weekday_name,
  interval,
  priority_entry,
  status_entry
FROM slot
WHERE 1=1
  AND is_deleted = 0
  AND datetime(slot) between datetime(?1) and datetime(?2)
  AND CASE WHEN ?3 == true THEN id_professional == ?4 ELSE 1 END
`

type ListSlotsParams struct {
	SlotInit       interface{} `json:"slot_init"`
	SlotEnd        interface{} `json:"slot_end"`
	IsProfessional interface{} `json:"is_professional"`
	IDProfessional int64       `json:"id_professional"`
}

type ListSlotsRow struct {
	IDSlot         int64     `json:"id_slot"`
	IDProfessional int64     `json:"id_professional"`
	IDAvailability int64     `json:"id_availability"`
	Slot           time.Time `json:"slot"`
	WeekdayName    string    `json:"weekday_name"`
	Interval       int64     `json:"interval"`
	PriorityEntry  int64     `json:"priority_entry"`
	StatusEntry    string    `json:"status_entry"`
}

func (q *Queries) ListSlots(ctx context.Context, arg ListSlotsParams) ([]ListSlotsRow, error) {
	rows, err := q.db.QueryContext(ctx, listSlots,
		arg.SlotInit,
		arg.SlotEnd,
		arg.IsProfessional,
		arg.IDProfessional,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSlotsRow
	for rows.Next() {
		var i ListSlotsRow
		if err := rows.Scan(
			&i.IDSlot,
			&i.IDProfessional,
			&i.IDAvailability,
			&i.Slot,
			&i.WeekdayName,
			&i.Interval,
			&i.PriorityEntry,
			&i.StatusEntry,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSlotsByIdAvailability = `-- name: ListSlotsByIdAvailability :many
SELECT
  id_slot
FROM slot
WHERE 1=1
  AND is_deleted = 0
  AND id_availability == ?1
`

func (q *Queries) ListSlotsByIdAvailability(ctx context.Context, idAvailability int64) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listSlotsByIdAvailability, idAvailability)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id_slot int64
		if err := rows.Scan(&id_slot); err != nil {
			return nil, err
		}
		items = append(items, id_slot)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
